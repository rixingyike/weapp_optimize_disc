{"version":3,"sources":["index.js","AsyncQueue.js","Event.js","PriorityQueue.js","Task.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const AsyncQueue = require('./AsyncQueue');\n\nmodule.exports = AsyncQueue;\n","const Event = require('./Event');\nconst PriorityQueue = require('./PriorityQueue');\nconst Task = require('./Task');\n\nclass AsyncQueue extends Event {\n  /**\n   * constructor\n   * @param {number} executeLimit Number of concurrentï¼ŒDefault: 1.\n   */\n  constructor (executeLimit = 1) {\n    super();\n    this._pause = false;\n    this.executeLimit = executeLimit;\n    this.executingQueue = [];\n    this.waitingQueue = new PriorityQueue();\n    this.eventHandlerMap = {};\n  }\n\n  addTask (...args) {\n    const task = new Task(...args);\n    task.options.createTime = this.getNowTimestamp();\n    if (this.executingQueue.length >= this.executeLimit || this.isPause) {\n      this.waitingQueue.enqueue(task);\n    } else {\n      this.executeTask(task);\n    }\n    this.emit('addTask', task.options);\n    return this;\n  }\n\n  async executeTask (task) {\n    this.executingQueue.push(task);\n    const { options, callback } = task;\n    const { context, delay, start, completed, failed } = options;\n    if (delay) {\n      await this.sleep(delay);\n    }\n    try {\n      start && start.call(context, this, options);\n      this.emit('startTask', options);\n      options.startTime = this.getNowTimestamp();\n      const result = await Promise.resolve(callback.call(context, this, options));\n      options.endTime = this.getNowTimestamp();\n      completed && completed.call(context, this, result);\n      this.emit('completed', options, result);\n    } catch (err) {\n      options.endTime = this.getNowTimestamp();\n      failed && failed.call(context, this, err);\n      this.emit('failed', options, err);\n    } finally {\n      this.changeTask(task);\n    }\n  }\n\n  nextTask () {\n    return this.waitingQueue.dequeue();\n  }\n\n  changeTask (task) {\n    if (task) {\n      const index = this.executingQueue.findIndex((item) => item === task);\n      this.executingQueue.splice(index, 1);\n    }\n    if (!this.isPause) {\n      const task = this.nextTask();\n      if (task) {\n        this.emit('changeTask', task.options);\n        this.executeTask(task);\n      }\n    }\n  }\n\n  clearTask () {\n    this.waitingQueue.clear();\n  }\n\n  removeTask (taskId) {\n    const { waitingQueue } = this;\n    for (let i = 0; i < waitingQueue.length(); i++) {\n      const { options } = waitingQueue.getTaskByIndex(i);\n      const { remove, context } = options;\n      if (options.id && options.id === taskId) {\n        remove && remove.call(context, this, options);\n        const isRemoved = waitingQueue.removeTaskByIndex(i);\n        this.emit('removeTask', options, isRemoved);\n        return isRemoved;\n      }\n    }\n    return false;\n  }\n\n  pause () {\n    this._pause = true;\n  }\n\n  get isPause () {\n    return this._pause;\n  }\n\n  resume () {\n    this._pause = false;\n    if (this.executingQueue.length < this.executeLimit) {\n      this.changeTask();\n    }\n  }\n\n  sleep (timestamp) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve();\n      }, timestamp);\n    });\n  }\n\n  setExcutingLimit (executeLimit) {\n    this.executeLimit = executeLimit;\n  }\n\n  getNowTimestamp () {\n    return new Date().getTime();\n  }\n}\n\nmodule.exports = AsyncQueue;\n","class Event {\n  constructor () {\n    this.eventHandlerMap = {};\n  }\n\n  on (eventName, eventHandler) {\n    if (typeof(eventHandler) !== 'function') {\n      throw new Error('eventHandler must be a function!');\n    }\n    if (!this.eventHandlerMap[eventName]) {\n      this.eventHandlerMap[eventName] = [];\n    }\n    const found = this.eventHandlerMap[eventName].find(handler => handler === eventHandler);\n    if (found) {\n      return;\n    }\n    this.eventHandlerMap[eventName].push(eventHandler);\n  }\n\n  emit (eventName, ...params) {\n    if (this.eventHandlerMap[eventName]) {\n      for (const eventHandler of this.eventHandlerMap[eventName]) {\n        eventHandler.call(this, ...params);\n      }\n    }\n  }\n\n  off (eventName, eventHandler) {\n    if (this.eventHandlerMap[eventName]) {\n      const index = this.eventHandlerMap[eventName].findIndex(handler => handler === eventHandler);\n      if (index >= 0) {\n        this.eventHandlerMap[eventName].splice(index, 1);\n      }\n    }\n  }\n}\n\nmodule.exports = Event;\n","class PriorityQueue {\n  constructor () {\n    this.taskList = [];\n  }\n\n  enqueue (task) {\n    const curWeight = task.options.weight || 0;\n    let insertIndex = this.length();\n    for (let i = insertIndex; i > 0; i--) {\n      const tmpWeight = this.getTaskByIndex(i - 1).weight || 0;\n      if (curWeight < tmpWeight) {\n        insertIndex = i - 1;\n        continue;\n      }\n      break;\n    }\n    this.addTaskByIndex(insertIndex, task);\n  }\n\n  dequeue () {\n    return this.taskList.shift();\n  }\n\n  addTaskByIndex (index, task) {\n    this.taskList.splice(index, 0, task);\n  }\n\n  getTaskByIndex (index) {\n    return this.taskList[index];\n  }\n\n  removeTaskByIndex (index) {\n    const removeArr = this.taskList.splice(index, 1);\n    return removeArr.length > 0;\n  }\n\n  clear () {\n    delete this.taskList;\n    this.taskList = [];\n  }\n\n  length () {\n    return this.taskList.length;\n  }\n}\n\nmodule.exports = PriorityQueue;\n","class Task {\n  constructor (...args) {\n    // default setting\n    this.options = {\n      id: undefined,\n      priority: 'normal',\n      weight: 0,\n      context: null,\n      createTime: 0,\n      startTime: 0,\n      endTime: 0,\n      start: () => {},\n      completed: () => {},\n      failed: () => {},\n      remove: () => {}\n    };\n    this.callback = () => {};\n    // initArgs\n    this.initArgs(...args);\n  }\n\n  initArgs (...args) {\n    const len = args.length;\n    if (len === 0) {\n      return;\n    }\n    if (len === 1) {\n      if (typeof args[0] === 'function') {\n        this.callback = args[0];\n      } else {\n        throw new Error('Invalid Argument For PAQ, Expected A Function!');\n      }\n    } else {\n      if (typeof args[0] === 'object') {\n        this.options = Object.assign(this.options, args[0]);\n        this.options.weight = this.setWeightByPriority();\n        this.validateArgs(this.options);\n      } else {\n        throw new Error('Invalid First Argument For PAQ, Expected A Object!');\n      }\n      if (typeof args[1] === 'function') {\n        this.callback = args[1];\n      } else {\n        throw new Error('Invalid Second Argument For PAQ, Expected A Function!');\n      }\n    }\n  }\n\n  setWeightByPriority () {\n    switch (this.options.priority) {\n    case 'low':\n      return 1;\n    case 'normal':\n      return 0;\n    case 'mid':\n      return -1;\n    case 'high':\n      return -2;\n    case 'urgent':\n      return -3;\n    default:\n      throw new Error('Please Choose A Correct Priority!');\n    }\n  }\n\n  validateArgs (options) {\n    if (typeof options.start !== 'function') {\n      throw new Error('Start callback must be a valid function!');\n    }\n    if (typeof options.completed !== 'function') {\n      throw new Error('Completed callback must be a valid function!');\n    }\n    if (typeof options.failed !== 'function') {\n      throw new Error('Failed callback must be a valid function!');\n    }\n    if (typeof options.remove !== 'function') {\n      throw new Error('Remove callback must be a valid function!');\n    }\n  }\n}\n\nmodule.exports = Task;\n"]}